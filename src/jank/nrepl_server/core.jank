(ns nrepl-server.core
  (:require
   [nrepl-server.server :as server :refer [read-message write-message connected?]]
   [nrepl-server.handler :refer [handle-message]]
   [nrepl-server.util :refer [abbreviate]]
   ;; handler implementations
   [nrepl-server.handler.clone]
   [nrepl-server.handler.close]
   [nrepl-server.handler.completions]
   [nrepl-server.handler.describe]
   [nrepl-server.handler.eval]
   [nrepl-server.handler.lookup]))

(def *verbose (atom false))

(defn log [& args]
  (when @*verbose
    (apply println args)))

(defn response-for
  "Given a request/response pair, copy the session identification data from the
  request over to the response."
  [req resp]
  (merge resp (select-keys req ["id" "session"])))

(defn responses-for
  "Like `response-for` but accept one or multiple responses."
  [req resp-or-resps]
  (let [resps (if (sequential? resp-or-resps)
                resp-or-resps
                [resp-or-resps])]
    (map #(response-for req %) resps)))

(defn handle-client
  "For as long as the client is connected, read requests and write replies."
  [client*]
  (while (connected? client*)
    (when-let [req (read-message client*)]
      (log "<-" (pr-str (abbreviate req 20)))
      (let [resps (responses-for req (handle-message req))]
        (doseq [resp resps]
          (log "->" (pr-str (abbreviate resp 20)))
          (write-message client* resp))))))

(defn -main [& args]
  (when (some #{"-v" "--verbose"} args)
    (reset! *verbose true))

  (let [listen-port 4200
        server      (server/listen listen-port)]
    (println (str "jank-nrepl listening for connections on port " listen-port "â€¦"))
    (while true
      ;; TODO(jank): Once we can spawn threads, we can spin out each client to a
      ;; background thread. Currently we can only handle one client at a time.
      (let [client* (server/accept server)]
        (handle-client client*)))))
